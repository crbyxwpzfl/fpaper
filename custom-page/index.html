<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Web Console & Image Dither</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css">
        /* --- webserial.html styles --- */
        div { display: block; }
        a { margin: 0rem; text-decoration: none; }
        *, ::after, ::before { box-sizing: inherit; }
        p { margin: 0 0 1rem; }
        body { overscroll-behavior: none; height: 100%; width: 100%; margin: 0; padding: 0; font-family:  -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif; }
        .text-center { text-align: center; }
        .gray { color: #667189; }
        .shadow { filter: drop-shadow(0 4px 3px rgba(0, 0, 0, 0)) drop-shadow(0 2px 2px rgba(0, 0, 0, 0.075)); }
        .w-full { font-family:  Menlo; font-size: 10px; width: 100%; }
        .grid { display: grid; }
        .gap-2 { gap: 0.5rem; }
        .flex { display: flex; }
        .grow { font-family:  Menlo; font-size: 20px; flex-grow: 1; }
        .justify-items-end { justify-items: end; }
        .rounded { border-radius: 0.5rem; }
        .section { box-sizing: border-box; background-color: #00000000; }
        .main { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; height: 70dvh; }
        .main .pannel { position: relative; border: #fff; border-style: solid; border-width: 0.5rem; border-radius: 1rem; background-color: #fff; width: calc(100% - 1rem); font-size: 10px; margin-top: 40px; }
        .pannel button { cursor: pointer; padding: 8px 10px 8px; font-size: 15px; outline-style: none; border: 0px; color: #ffffff; background-color: #0067f4; }
        .pannel button:disabled { background-color: #5a6169; }
        .pannel #record { min-height: 3rem; padding: 0.5rem; resize: vertical; overscroll-behavior: none; }
        #control-button { position: absolute; top: 0.5rem; right: 0.5rem; }
        #control-button button { background-color: #5a6169; }
        .alert span { user-select: none; background: #ffe14d; padding: 1px 10px; display: block; color: black; }
        .footer { padding: 1rem 0.5rem; background-color: white; }
        .copyright { padding-bottom: 1rem; }
        .float-left { float: left; }
        .float-right { float: right; }
        /* --- overlay styles --- */
        #imgOverlayBg {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0; top: 0; width: 100vw; height: 100vh;
            /* background: rgba(0,0,0,0.6); */
            background: rgba(0, 0, 0, 0.075);
            justify-content: center;
            align-items: center;
        }
        #imgOverlay {
            position: relative;
            background: none;
            border-radius: 1.5rem;
            overflow: visible;
            box-shadow: 0 0 32px 8px rgba(0,0,0,0.2);
            /*max-width: 90vw;
            height: 90vh;
            object-fit: contain;*/
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #imgRegionContainer {
            position: relative;
            display: inline-block;
            background: none;
        }
        #popupImage {
            display: block;
            max-width: 90vw;
            /*max-height: 90vh;
            width: auto;
            height: auto;
            object-fit: contain*/
            border-radius: 1.5rem;
            background: #fff;
        }
        #region {
            position: absolute;
            cursor: move;
            box-sizing: border-box;
            display: none;
            touch-action: none;
            border: 2px dashed rgb(0, 0, 0);
            border-radius: 0.5rem;
        }
        #ditheredOverlay {
            position: absolute;
            left: 0; top: 0;
            display: none;
            pointer-events: none;
            border-radius: 0.5rem;
        }
        #sendBtn {
            position: absolute;
            z-index: 10;
            /* Remove right/bottom, use JS for pixel positioning */
            background: #0067f4;
            color: #fff;
            border: none;
            border-radius: 0.7rem;
            padding: 0.5rem 0.5rem;
            font-size: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            cursor: pointer;
            display: none;
            /* Fixed size, do not scale with overlay */
            width: auto;
            height: auto;
            min-width: 1px;
            min-height: 1px;
            /* Prevent scaling */
            transform: none !important;
        }

        /* 
        @media (max-width: 600px) {
            #popupImage { max-width: 98vw; max-height: 60vh; }
        }
        */

    </style>
</head>
<body>
    <div class="section main text-center">
        <!-- <h1 id="title" style="display: none;">WebSerial</h1>
         <a href="/">
            <img id="logo" src="/logo" onerror="removeLogo();" />
        </a> -->
        <div class="pannel shadow grid gap-2">
            <div id="control-button">
                <button class="rounded shadow" onclick="terminalClean()">
                    <svg viewBox="64 64 896 896" focusable="false" data-icon="delete" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M864 256H736v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zm-200 0H360v-72h304v72z"></path></svg>
                </button>
                <button class="rounded shadow" onclick="enableFlowLock=!enableFlowLock">
                    <svg viewBox="64 64 896 896" focusable="false" data-icon="lock" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M832 464h-68V240c0-70.7-57.3-128-128-128H388c-70.7 0-128 57.3-128 128v224h-68c-17.7 0-32 14.3-32 32v384c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V496c0-17.7-14.3-32-32-32zM332 240c0-30.9 25.1-56 56-56h248c30.9 0 56 25.1 56 56v224H332V240zm460 600H232V536h560v304zM484 701v53c0 4.4 3.6 8 8 8h40c4.4 0 8-3.6 8-8v-53a48.01 48.01 0 10-56 0z"></path></svg>
                </button>
                <button class="rounded shadow" onclick="enableTimestamp=!enableTimestamp">
                    <svg viewBox="64 64 896 896" focusable="false" data-icon="clock-circle" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"></path><path d="M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z"></path></svg>
                </button>
            </div>
            <textarea class="w-full rounded" title="record" id="record" cols="50" rows="50" disabled></textarea>
            <div class="flex w-full grid gap-2" id="terminal">
                <input type="text" name="cmd" id="command-text" class="grow rounded" /><button class="grid justify-items-end rounded shadow" id="command-button">SEND</button>
                <button class="grid justify-items-end rounded shadow" id="img-button">CHOOSE FILE</button>
                <input type="file" id="imgInput" accept="image/*" style="display:none;" />
            </div>
        </div>
        <h1 />
    </div>
    <!-- Overlay for image region selection and dithering -->
    <div id="imgOverlayBg">
        <div id="imgOverlay">
            <div id="imgRegionContainer">
                <img id="popupImage" src="#" alt="your image" style="display:none;" />
                <canvas id="ditheredOverlay" width="300" height="400" style="display:none;"></canvas>
                <div id="region" style="display:none;"></div>
                <button id="sendBtn">SEND</button>
            </div>
        </div>
    </div>
    <!-- <script src="../original-page/js/dithering.js"></script> -->
    <script>
    // ...existing code from webserial.html for WebSocket, terminal, etc...
    let gateway = `ws://${window.location.host + window.location.pathname}ws`;
    let websocket;
    let textArea = document.getElementById("record");
    let enableFlowLock = false;
    let enableTimestamp = false;
    let pingTimeout;
    let connectTimeout;
    let commandHistory = [];
    let commandHistoryIdx = 0;
    function removeLogo() {
        document.getElementById("logo").remove();
        document.getElementById("title").style.display = "block";
    }
    function initWebPage() {
        document.getElementById("command-button").disabled = true;
        document.getElementById("command-text").disabled = true;
        initCommandHistory();
        initWebSocket();
        initButton();
        trapKeyPress();
        // Image button
        document.getElementById('img-button').addEventListener('click', function() {
            document.getElementById('imgInput').click();
        });
        document.getElementById('imgInput').addEventListener('change', handleImageFile);
    }
    function initCommandHistory() {
        const json = localStorage.history;
        commandHistory = json ? JSON.parse(json) : [];
        commandHistoryIdx = commandHistory.length;
    }
    function initWebSocket() {
        clearTimeout(connectTimeout);
        clearTimeout(pingTimeout);
        pingTimeout = false;
        connectTimeout = setTimeout(() => {
            terminalWrite("search timeout");
            websocket.close();
            initWebSocket();
        }, 3000);
        terminalWrite("please wait while searching.... ");
        websocket = new WebSocket(gateway);
        websocket.onopen = onOpen;
        websocket.onclose = onClose;
        websocket.onmessage = onMessage;
        websocket.onerror = onError;
    }
    function initButton() {
        document.getElementById("command-button").addEventListener("click", sendCommand);
    }
    function trapKeyPress() {
        document.getElementById("command-text").addEventListener("keypress", (event) => {
            if (event.code === "Enter") {
                event.preventDefault();
                document.getElementById("command-button").click();
            }
        });
        document.addEventListener("keydown", (event) => {
            if (document.activeElement && document.activeElement.id === 'command-text') {
                if (event.code === "ArrowUp") {
                    commandHistoryIdx--;
                    if (commandHistoryIdx < 0)
                        commandHistoryIdx = commandHistory.length > 0 ? commandHistory.length - 1 : 0;
                    if (commandHistoryIdx >= 0 && commandHistoryIdx < commandHistory.length)
                        document.getElementById("command-text").value = commandHistory[commandHistoryIdx];
                } else if (event.code === "ArrowDown") {
                    commandHistoryIdx++;
                    if (commandHistoryIdx >= commandHistory.length)
                        commandHistoryIdx = 0;
                    if (commandHistoryIdx >= 0 && commandHistoryIdx < commandHistory.length)
                        document.getElementById("command-text").value = commandHistory[commandHistoryIdx];
                }
            }
        });
    }
    function onOpen(event) {
        clearTimeout(connectTimeout);
        terminalWrite("found portal try 'help' for configuration");
        document.getElementById("command-button").disabled = false;
        document.getElementById("command-text").disabled = false;
    }
    function onError(e) {
        console.log("Error!", e);
        websocket.close();
    }
    function onClose(e) {
        console.log("connection closed.", e);
    }
    function onMessage(event) {
        if (event.data == 'pong') {
            clearTimeout(pingTimeout);
            pingTimeout = false;
        } else {
            terminalWrite(event.data);
        }
    }
    function terminalWrite(raw) {
        if (enableTimestamp) {
            let now = new Date();
            raw = "[" + now.toLocaleTimeString() + "] " + raw + "\n";
        }
        textArea.value += raw + "\n";
        if (!enableFlowLock) {
            textArea.scrollTop = textArea.scrollHeight;
        }
    }
    function terminalClean() {
        textArea.value = "";
        textArea.scrollTop = textArea.scrollHeight;
    }
    function sendCommand() {
        let cmd = document.getElementById("command-text").value;
        console.log('send command: ', cmd);
        websocket.send(cmd);
        commandHistory.push(cmd);
        if (commandHistory.length > 20) {
            commandHistory.splice(0, commandHistory.length - 20);
        }
        commandHistoryIdx = commandHistory.length;
        document.getElementById("command-text").value = "";
        localStorage.history = JSON.stringify(commandHistory);
    }
    setInterval(() => {
        if (!pingTimeout && websocket.readyState == WebSocket.OPEN) {
            pingTimeout = setTimeout(() => {
                terminalWrite("Ping timeout.");
                websocket.close();
                initWebSocket();
            }, 3000);
            websocket.send("ping");
        }
    }, 2000);
    window.addEventListener("DOMContentLoaded", function () {
        initWebPage();
    }, false);





    // this is https://github.com/javl/image2cpp this dithereing is so cool!
    // eslint-disable no-plusplus //
    const bwrPalette = [
    [0, 0, 0, 255],
    [255, 255, 255, 255],
    [255, 0, 0, 255],
    ];

    const bwPalette = [
    [0, 0, 0, 255],
    [255, 255, 255, 255],
    ];

    function dithering(ctx, width, height, threshold, typeIndex) {
    const type = ['binary', 'bayer', 'floydsteinberg', 'atkinson'][typeIndex];
    const bayerThresholdMap = [
        [15, 135, 45, 165],
        [195, 75, 225, 105],
        [60, 180, 30, 150],
        [240, 120, 210, 90],
    ];

    const lumR = [];
    const lumG = [];
    const lumB = [];
    for (let i = 0; i < 256; i++) {
        lumR[i] = i * 0.299;
        lumG[i] = i * 0.587;
        lumB[i] = i * 0.114;
    }
    const imageData = ctx.getImageData(0, 0, width, height);

    const imageDataLength = imageData.data.length;

    // Greyscale luminance (sets r pixels to luminance of rgb)
    for (let i = 0; i <= imageDataLength; i += 4) {
        imageData.data[i] =
        Math.floor(lumR[imageData.data[i]] + lumG[imageData.data[i + 1]] + lumB[imageData.data[i + 2]]);
    }

    const w = imageData.width;
    let newPixel; let
        err;

    for (let currentPixel = 0; currentPixel <= imageDataLength; currentPixel += 4) {
        if (type === 'binary') {
        // No dithering
        imageData.data[currentPixel] = imageData.data[currentPixel] < threshold ? 0 : 255;
        } else if (type === 'bayer') {
        // 4x4 Bayer ordered dithering algorithm
        // eslint-disable-next-line no-mixed-operators
        const x = currentPixel / 4 % w;
        const y = Math.floor(currentPixel / 4 / w);
        const map = Math.floor((imageData.data[currentPixel] + bayerThresholdMap[x % 4][y % 4]) / 2);
        imageData.data[currentPixel] = (map < threshold) ? 0 : 255;
        } else if (type === 'floydsteinberg') {
        // Floydaâ‚¬"Steinberg dithering algorithm
        newPixel = imageData.data[currentPixel] < 129 ? 0 : 255;
        err = Math.floor((imageData.data[currentPixel] - newPixel) / 16);
        imageData.data[currentPixel] = newPixel;

        imageData.data[currentPixel + 4] += err * 7;
        imageData.data[currentPixel + 4 * w - 4] += err * 3;
        imageData.data[currentPixel + 4 * w] += err * 5;
        imageData.data[currentPixel + 4 * w + 4] += err * 1;
        } else if (type === 'atkinson') {
        // Bill Atkinson's dithering algorithm
        newPixel = imageData.data[currentPixel] < threshold ? 0 : 255;
        err = Math.floor((imageData.data[currentPixel] - newPixel) / 8);
        imageData.data[currentPixel] = newPixel;

        imageData.data[currentPixel + 4] += err;
        imageData.data[currentPixel + 8] += err;
        imageData.data[currentPixel + 4 * w - 4] += err;
        imageData.data[currentPixel + 4 * w] += err;
        imageData.data[currentPixel + 4 * w + 4] += err;
        imageData.data[currentPixel + 8 * w] += err;
        } else {
        console.error(`unknown dithering type requested: ${type}`);
        }

        // Set g and b pixels equal to r
        imageData.data[currentPixel + 1] = imageData.data[currentPixel + 2] = imageData.data[currentPixel];
    }

    ctx.putImageData(imageData, 0, 0);
    }

    function canvas2bytes(canvas, type = 'bw') {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        const arr = [];
        let buffer = [];

        for (let x = canvas.width - 1; x >= 0; x--) {
            for (let y = 0; y < canvas.height; y++) {
                const index = (canvas.width * 4 * y) + x * 4;
                if (type !== 'bwr') {
                    buffer.push(imageData.data[index] > 0 && imageData.data[index + 1] > 0 && imageData.data[index + 2] > 0 ? 1 : 0);
                } else {
                    buffer.push(imageData.data[index] > 0 && imageData.data[index + 1] === 0 && imageData.data[index + 2] === 0 ? 1 : 0);
                }

                if (buffer.length === 8) {
                    arr.push(parseInt(buffer.join(''), 2));
                    buffer = [];
                }
            }
        }
        return arr;
    }

    function getColorDistance(rgba1, rgba2) {
        const [r1, b1, g1] = rgba1;
        const [r2, b2, g2] = rgba2;

        const rm = (r1 + r2) / 2;

        const r = r1 - r2;
        const g = g1 - g2;
        const b = b1 - b2;

        return Math.sqrt((2 + rm / 256) * r * r + 4 * g * g + (2 + (255 - rm) / 256) * b * b);
    }

    function getNearColor(pixel, palette) {
        let minDistance = 255 * 255 * 3 + 1;
        let paletteIndex = 0;

        for (let i = 0; i < palette.length; i++) {
            const targetColor = palette[i];
            const distance = getColorDistance(pixel, targetColor);
            if (distance < minDistance) {
            minDistance = distance;
            paletteIndex = i;
            }
        }

        return palette[paletteIndex];
    }

    function getNearColorV2(color, palette) {
        let minDistanceSquared = 255 * 255 + 255 * 255 + 255 * 255 + 1;

        let bestIndex = 0;
        for (let i = 0; i < palette.length; i++) {
            const rdiff = (color[0] & 0xff) - (palette[i][0] & 0xff);
            const gdiff = (color[1] & 0xff) - (palette[i][1] & 0xff);
            const bdiff = (color[2] & 0xff) - (palette[i][2] & 0xff);
            const distanceSquared = rdiff * rdiff + gdiff * gdiff + bdiff * bdiff;
            if (distanceSquared < minDistanceSquared) {
            minDistanceSquared = distanceSquared;
            bestIndex = i;
            }
        }
        return palette[bestIndex];
    }

    function updatePixel(imageData, index, color) {
        imageData[index] = color[0];
        imageData[index + 1] = color[1];
        imageData[index + 2] = color[2];
        imageData[index + 3] = color[3];
    }

    function getColorErr(color1, color2, rate) {
        const res = [];
        for (let i = 0; i < 3; i++) {
            res.push(Math.floor((color1[i] - color2[i]) / rate));
        }
        return res;
    }

    function updatePixelErr(imageData, index, err, rate) {
        imageData[index] += err[0] * rate;
        imageData[index + 1] += err[1] * rate;
        imageData[index + 2] += err[2] * rate;
    }

    function ditheringCanvasByPalette(canvas, palette, type) {
        palette = palette || bwrPalette;

        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const w = imageData.width;

        for (let currentPixel = 0; currentPixel <= imageData.data.length; currentPixel += 4) {
            const newColor = getNearColorV2(imageData.data.slice(currentPixel, currentPixel + 4), palette);

            if (type === 'bwr_floydsteinberg') {
                const err = getColorErr(imageData.data.slice(currentPixel, currentPixel + 4), newColor, 16);

                updatePixel(imageData.data, currentPixel, newColor);
                updatePixelErr(imageData.data, currentPixel + 4, err, 7);
                updatePixelErr(imageData.data, currentPixel + 4 * w - 4, err, 3);
                updatePixelErr(imageData.data, currentPixel + 4 * w, err, 5);
                updatePixelErr(imageData.data, currentPixel + 4 * w + 4, err, 1);
            } else {
                const err = getColorErr(imageData.data.slice(currentPixel, currentPixel + 4), newColor, 8);

                updatePixel(imageData.data, currentPixel, newColor);
                updatePixelErr(imageData.data, currentPixel + 4, err, 1);
                updatePixelErr(imageData.data, currentPixel + 8, err, 1);
                updatePixelErr(imageData.data, currentPixel + 4 * w - 4, err, 1);
                updatePixelErr(imageData.data, currentPixel + 4 * w, err, 1);
                updatePixelErr(imageData.data, currentPixel + 4 * w + 4, err, 1);
                updatePixelErr(imageData.data, currentPixel + 8 * w, err, 1);
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }



    // --- Image region selection and dithering overlay logic (from image.html, adapted) ---
    const imgOverlayBg = document.getElementById('imgOverlayBg');
    const imgOverlay = document.getElementById('imgOverlay');
    const imgRegionContainer = document.getElementById('imgRegionContainer');
    const popupImage = document.getElementById('popupImage');
    const region = document.getElementById('region');
    const ditheredOverlay = document.getElementById('ditheredOverlay');
    const sendBtn = document.getElementById('sendBtn');
    let dragging = false, resizing = false, startX, startY, startLeft, startTop, startWidth, startHeight;
    let regionData = {left: 50, top: 50, width: 150, height: 200}; // default 3:4
    let imgRect = null;
    let lastTouchDist = null;
    function handleImageFile(evt) {
        const [file] = evt.target.files;
        if (file) {
            popupImage.src = URL.createObjectURL(file);
            popupImage.style.display = 'block';
            imgOverlayBg.style.display = 'flex';
            popupImage.onload = () => {
                // scale image by orientation to avoid stretching
                // also just max-heigth and max-width does not work since small images wont get scaled up to their max height/width
                // object-fit: contain does not work since the ditthering then for some reason uses a stretched version of the image.
                popupImage.style.removeProperty('max-width');
                popupImage.style.removeProperty('max-height');
                popupImage.style.removeProperty('width');
                popupImage.style.removeProperty('height');
                imgOverlay.style.removeProperty('max-width');
                imgOverlay.style.removeProperty('width');
                imgOverlay.style.removeProperty('height');
                imgOverlay.style.removeProperty('max-height');
                if (popupImage.naturalWidth >= popupImage.naturalHeight) {
                    popupImage.style.width = '90vw';
                    popupImage.style.maxHeight = '90vh';
                    imgOverlay.style.width = '90vw';
                    imgOverlay.style.maxHeight = '90vh';
                }
                if (popupImage.naturalWidth < popupImage.naturalHeight) {
                    popupImage.style.maxWidth = '90vw';
                    popupImage.style.height = '90vh';
                    imgOverlay.style.maxWidth = '90vw';
                    imgOverlay.style.height = '90vh';
                }
                imgRect = popupImage.getBoundingClientRect();
                const iw = popupImage.width, ih = popupImage.height;
                let rw = iw * 0.5, rh = rw * 4/3;
                if (rh > ih) { rh = ih * 0.5; rw = rh * 3/4; }
                regionData = {
                    left: (iw - rw) / 2,
                    top: (ih - rh) / 2,
                    width: rw,
                    height: rh
                };
                region.style.display = 'block';
                ditheredOverlay.style.display = 'block';
                sendBtn.style.display = 'block';
                updateRegion();
            };
        }
    }
    function updateRegion() {
        if (!popupImage.width || !popupImage.height) return;
        region.style.left = regionData.left + 'px';
        region.style.top = regionData.top + 'px';
        region.style.width = regionData.width + 'px';
        region.style.height = regionData.height + 'px';
        ditheredOverlay.style.left = regionData.left + 'px';
        ditheredOverlay.style.top = regionData.top + 'px';
        ditheredOverlay.width = 300;
        ditheredOverlay.height = 400;
        ditheredOverlay.style.width = regionData.width + 'px';
        ditheredOverlay.style.height = regionData.height + 'px';
        ditheredOverlay.style.display = 'block';
        // Position SEND button at bottom right of overlay region, fixed size
        sendBtn.style.left = (regionData.left + regionData.width - sendBtn.offsetWidth + 10 ) + 'px';
        sendBtn.style.top = (regionData.top + regionData.height - sendBtn.offsetHeight + 20 ) + 'px';
        sendBtn.style.display = 'block';
        if (popupImage.src && popupImage.complete && regionData.width > 0 && regionData.height > 0) {
            const scaleX = popupImage.naturalWidth / popupImage.width;
            const scaleY = popupImage.naturalHeight / popupImage.height;
            const sx = regionData.left * scaleX;
            const sy = regionData.top * scaleY;
            const sw = regionData.width * scaleX;
            const sh = regionData.height * scaleY;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 300; tempCanvas.height = 400;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(popupImage, sx, sy, sw, sh, 0, 0, 300, 400);
            dithering(tempCtx, 300, 400, 128, 3);
            const overlayCtx = ditheredOverlay.getContext('2d');
            overlayCtx.clearRect(0, 0, 300, 400);
            overlayCtx.drawImage(tempCanvas, 0, 0, 300, 400);
        }
    }
    region.addEventListener('mousedown', function(e) {
        dragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = regionData.left;
        startTop = regionData.top;
        document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', function(e) {
        if (dragging && imgOverlayBg.style.display === 'flex') {
            let dx = e.clientX - startX;
            let dy = e.clientY - startY;
            let newLeft = Math.max(0, Math.min(popupImage.width - regionData.width, startLeft + dx));
            let newTop = Math.max(0, Math.min(popupImage.height - regionData.height, startTop + dy));
            regionData.left = newLeft;
            regionData.top = newTop;
            updateRegion();
        }
    });
    document.addEventListener('mouseup', function() {
        dragging = false;
        document.body.style.userSelect = '';
    });
    region.addEventListener('wheel', function(e) {
        e.preventDefault();
        let scale = e.deltaY < 0 ? 1.05 : 0.95;
        if (e.ctrlKey) scale = e.deltaY < 0 ? 1.01 : 0.99;
        let newWidth = regionData.width * scale;
        let newHeight = newWidth * 4/3;
        // Clamp to image size
        if (newWidth < 30 || newHeight < 40) return;
        if (newWidth > popupImage.width) newWidth = popupImage.width, newHeight = newWidth * 4/3;
        if (newHeight > popupImage.height) newHeight = popupImage.height, newWidth = newHeight * 3/4;
        // Calculate center before scaling
        let centerX = regionData.left + regionData.width / 2;
        let centerY = regionData.top + regionData.height / 2;
        // Move region to keep it inside image after scaling
        let newLeft = centerX - newWidth / 2;
        let newTop = centerY - newHeight / 2;
        if (newLeft < 0) newLeft = 0;
        if (newTop < 0) newTop = 0;
        if (newLeft + newWidth > popupImage.width) newLeft = popupImage.width - newWidth;
        if (newTop + newHeight > popupImage.height) newTop = popupImage.height - newHeight;
        regionData.width = newWidth;
        regionData.height = newHeight;
        regionData.left = newLeft;
        regionData.top = newTop;
        updateRegion();
    });
    region.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            dragging = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            startLeft = regionData.left;
            startTop = regionData.top;
        } else if (e.touches.length === 2) {
            resizing = true;
            lastTouchDist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            startWidth = regionData.width;
            startHeight = regionData.height;
        }
    }, { passive: false });
    region.addEventListener('touchmove', function(e) {
        e.preventDefault();
        if (dragging && e.touches.length === 1) {
            let dx = e.touches[0].clientX - startX;
            let dy = e.touches[0].clientY - startY;
            let newLeft = Math.max(0, Math.min(popupImage.width - regionData.width, startLeft + dx));
            let newTop = Math.max(0, Math.min(popupImage.height - regionData.height, startTop + dy));
            regionData.left = newLeft;
            regionData.top = newTop;
            updateRegion();
        } else if (resizing && e.touches.length === 2) {
            let dist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            let scale = dist / lastTouchDist;
            let newWidth = startWidth * scale;
            let newHeight = newWidth * 4/3;
            if (newWidth < 30 || newHeight < 40) return;
            if (newWidth > popupImage.width) newWidth = popupImage.width, newHeight = newWidth * 4/3;
            if (newHeight > popupImage.height) newHeight = popupImage.height, newWidth = newHeight * 3/4;
            let centerX = regionData.left + regionData.width / 2;
            let centerY = regionData.top + regionData.height / 2;
            let newLeft = centerX - newWidth / 2;
            let newTop = centerY - newHeight / 2;
            if (newLeft < 0) newLeft = 0;
            if (newTop < 0) newTop = 0;
            if (newLeft + newWidth > popupImage.width) newLeft = popupImage.width - newWidth;
            if (newTop + newHeight > popupImage.height) newTop = popupImage.height - newHeight;
            regionData.width = newWidth;
            regionData.height = newHeight;
            regionData.left = newLeft;
            regionData.top = newTop;
            updateRegion();
        }
    }, { passive: false });
    region.addEventListener('touchend', function(e) {
        dragging = false;
        resizing = false;
        e.preventDefault();
    }, { passive: false });
    // SEND button logic
    sendBtn.addEventListener('click', function() {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 300; tempCanvas.height = 400;
        const tempCtx = tempCanvas.getContext('2d');
        const scaleX = popupImage.naturalWidth / popupImage.width;
        const scaleY = popupImage.naturalHeight / popupImage.height;
        const sx = regionData.left * scaleX;
        const sy = regionData.top * scaleY;
        const sw = regionData.width * scaleX;
        const sh = regionData.height * scaleY;
        tempCtx.save();
        tempCtx.translate(150, 200);
        tempCtx.drawImage(popupImage, sx, sy, sw, sh, -150, -200, 300, 400);
        tempCtx.restore();
        dithering(tempCtx, 300, 400, 128, 3);
        const bytes = canvas2bytes(tempCanvas, 'bw');
        const byteArray = new Uint8Array(bytes);
        const blob = new Blob([byteArray], {type: 'application/octet-stream'});
        const formData = new FormData();
        formData.append('file', blob, 'image.bin');
        fetch('/file', { method: 'POST', body: formData });
        closeOverlay();
    });
    // Close overlay on click outside
    imgOverlayBg.addEventListener('mousedown', function(e) {
        if (e.target === imgOverlayBg) closeOverlay();
    });
    imgOverlayBg.addEventListener('touchstart', function(e) {
        if (e.target === imgOverlayBg) closeOverlay();
    });
    function closeOverlay() {
        imgOverlayBg.style.display = 'none';
        popupImage.src = '#';
        popupImage.style.display = 'none';
        region.style.display = 'none';
        ditheredOverlay.style.display = 'none';
        sendBtn.style.display = 'none';
    }
    </script>
</body>
</html>
